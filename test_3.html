<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scatterplot d3v4</title>
    <style type="text/css">
        body{
            margin: 0;
            font-family: arial, sans;
        }

        .label{
            font-size: 15px;
        }

        .legend text,
        .axis text {
            font-size: 13px;
            fill: #333;
        }

        .axis path,
        .axis line{
            fill: none;
            stroke-width: 1px;
            stroke: #777;
        }

        .circle{
            fill-opacity: 0.65;
        }

        .bubble{
            opacity: 1;
            transition: opacity 0.3s;
        }

        .bubble:hover text{
            opacity: 1;
        }

        .bubble:hover circle{
            fill-opacity: 1;
        }

        .legend rect{
            fill-opacity: 0.75;
        }

        .legeng:hover rect{
            fill-opacity:1;
        }



        .svg_chart_d3-tip {
            line-height: 1;
            padding: 6px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Creates a small triangle extender for the tooltip */
        .svg_chart_d3-tip:after {
            box-sizing: border-box;
            display: inline;
            font-size: 10px;
            width: 100%;
            line-height: 1;
            color: rgba(0, 0, 0, 0.8);
            content: "\25BC";
            position: absolute;
            text-align: center;
        }

        /* Style northward tooltips specifically */
        .svg_chart_d3-tip.n:after {
            margin: -2px 0 0 0;
            top: 100%;
            left: 0;
        }





        .svg_graph_d3-tip {
            line-height: 1;
            padding: 6px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Creates a small triangle extender for the tooltip */
        .svg_graph_d3-tip:after {
            box-sizing: border-box;
            display: inline;
            font-size: 10px;
            width: 100%;
            line-height: 1;
            color: rgba(0, 0, 0, 0.8);
            content: "\25BC";
            position: absolute;
            text-align: center;
        }

        /* Style northward tooltips specifically */
        .svg_graph_d3-tip.n:after {
            margin: -2px 0 0 0;
            top: 100%;
            left: 0;
        }







        .node circle {
            fill: #999;
            stroke: #37b4d2;
            stroke-width: 0px;
        }

        .node text {
            font: 10px sans-serif;
        }

        .node--internal circle {
            fill: #555;
        }

        .node--internal text {
            text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
        }

        .link {
            fill: none;
            stroke: #555;
            stroke-opacity: 1;
            stroke-width: 1.5px;
        }



        .slideComponent{

            position: absolute;
            left: 100px;
            top: 150px;
        }


        /* Style for loader specifically */
        .loader {
            border: 16px solid #f3f3f3; /* Light grey */
            border-top: 16px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 120px;
            height: 120px;
            position: absolute;
            z-index: 15;
            top: 50%;
            left: 50%;
            margin: -100px 0 0 -150px;
            animation: spin 2s linear infinite;
        }

        /* Style for loader specifically */
        .loader.hidden {
            visibility: hidden;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }



    </style>
    <!--<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>-->
    <script type="text/javascript" src="http://localhost:8080/js/d3.min.js"></script>

    <!-- load the d3.tip.js library -->
    <script type="text/javascript" src="http://localhost:8080/js/d3-tip.js"></script>

    <!-- load the grid.js  -->
    <script src="http://localhost:8080/js/grid.js" type="text/javascript"></script>

    <!-- load the d3-context-menu.js  -->
    <script src="http://localhost:8080/js/d3-context-menu.js"></script>


    <link rel="stylesheet" type="text/css" href="http://localhost:8080/css/d3-context-menu.css">

</head>
<body>
<div class="loader" id="tempLoader"></div>



<div class="slideComponent">

</div>




<script type="text/javascript">

    var treeIsDrew = false;

    var margin = {top: 30, right: 50, bottom: 50, left:40};
    var width = 960 - margin.left - margin.right;
    var height = 500 - margin.top - margin.bottom;

    var svg_chart = d3.select('body')
        .attr('class', 'svg_chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


    // The API for scales have changed in v4. There is a separate module d3-scale which can be used instead. The main change here is instead of d3.scale.linear, we have d3.scaleLinear.
    var xScale = d3.scaleLinear()
        .range([width, 0]);

    var yScale = d3.scaleLinear()
        .range([height, 0]);

    // square root scale.
    var radius = d3.scaleSqrt()
        .range([5,15]);

    // the axes are much cleaner and easier now. No need to rotate and orient the axis, just call axisBottom, axisLeft etc.
    var xAxis = d3.axisBottom()
        .scale(xScale);

    var yAxis = d3.axisLeft()
        .scale(yScale);

    // again scaleOrdinal
    var color = d3.scaleOrdinal(d3.schemeCategory20);

    var colorSet = ["#3EF2F2", "#7B5DFF", "#FF594A", "#FFDC31", "#61FF6A" ];

    // Variables for clustering

    var dimensionsForClustering = ["editedDistanceFromRoot","score"];
    var currentSelectedNode;


    // Loader
    var loader = document.getElementById("tempLoader");
    loader.style.display = "none";


    // For contextmenu
    var Graph_menu = [
        {
            title: 'Extend tree from this state',
            action: function(elm, d, i) {
                console.log('Item #1 clicked!');
                console.log('The data for this circle is: ' + d);
            }
        },
        {
            title: 'Send this state to Cicero to Rerun',
            action: function(elm, d, i) {
                console.log('You have clicked the second item!');
                console.log('The data for this circle is: ' + d);
            }
        }
    ]


    var Graph_BG_menu = [
        {
            title: 'Expand all tree nodes',
            action: function(elm, d, i) {
                console.log('Item #1 clicked!');
                console.log('The data for this circle is: ' + d);
            }
        },
        {
            title: 'Send this state to Cicero to Rerun',
            action: function(elm, d, i) {
                console.log('You have clicked the second item!');
                console.log('The data for this circle is: ' + d);
            }
        }
    ]

    var menu = [
        {
            title: 'Extend tree from this state',
            action: function(elm, d, i) {
                console.log('Item #1 clicked!');
                console.log('The data for this circle is: ' + d);
            }
        },
        {
            title: 'Send this state to Cicero to Rerun',
            action: function(elm, d, i) {
                console.log('You have clicked the second item!');
                console.log('The data for this circle is: ' + d);
            }
        }
    ]


    // Set up the ToolTips

    var chart_tool_tip = d3.tip()
        .attr('class', 'svg_chart_d3-tip')
        .offset([-10, 0])
        .html(function(d) {
            return "<strong>Persona Type: </strong> <span style='color:red'>" + d.personaType + "</span>" + "<br>" + "<br>" +

                "<strong>TreeNode File Name: </strong> <span style='color:red'>" + d.TreeNodeFileName + "</span>" + "<br>" +

                "<strong>Number of Winnings: </strong> <span style='color:red'>" + d.gotGoalNum + "</span>" + "<br>" +
                "<strong>Number of Losses: </strong> <span style='color:red'>" + d.gotKilledNum + "</span>" + "<br>" +

                "<strong>Enemy Killed: </strong> <span style='color:red'>" + d.killedEnemyNum + "</span>" + "<br>" +

                "<strong>Resrouces Obtained: </strong> <span style='color:red'>" + d.gotResourceNum + "</span>" + "<br>" +

                "<strong>Total Avatar Events: </strong> <span style='color:red'>" + d.totalAvatarEvents + "</span>" + "<br>";
        });



    svg_chart.call(chart_tool_tip);


    d3.json('http://localhost:8080/jsonFiles/RootNodes.json', function(error, data){
        data.forEach(function(d){
            d.elapsedTime = +d.elapsedTime;  // X
            d.numNodesVisited = +d.numNodesVisited;  // Y
            d.height = +d.height; // radius
//            d.TreeNodeFileName = d.TreeNodeFileName;
        });




        xScale.domain(d3.extent(data, function(d){
            return d.elapsedTime;
        })).nice();

        yScale.domain(d3.extent(data, function(d){
            return d.numNodesVisited;
        })).nice();

        radius.domain(d3.extent(data, function(d){
            return d.height;
        })).nice();

        // adding axes is also simpler now, just translate x-axis to (0,height) and it's alread defined to be a bottom axis.
        svg_chart.append('g')
            .attr('transform', 'translate(0,' + 420 + ')')
            .attr('class', 'x axis')
            .call(xAxis);

        // y-axis is translated to (0,0)
        svg_chart.append('g')
            .attr('transform', 'translate(0,0)')
            .attr('class', 'y axis')
            .call(yAxis);


        var bubble = svg_chart.selectAll('.bubble')
            .data(data)
            .enter().append('circle')
            .attr('class', 'bubble')
            .attr('cx', function(d){return xScale(d.elapsedTime);})
            .attr('cy', function(d){ return yScale(d.numNodesVisited); })
            .attr('r', function(d){ return radius(d.height); })
            .style('fill', function(d){ return color(d.personaType); })
            .on('mouseover', chart_tool_tip.show)
            .on('mouseout', chart_tool_tip.hide)
            .on('click', function(d){

//                console.log(d.TreeNodeFileName);

                currentJsonFile = "http://localhost:8080/jsonFiles/" + d.TreeNodeFileName;

//                console.log(currentJsonFile);


                if (treeIsDrew){


                    d3.selectAll(".svg_treeGraph").remove();

                    treeDraw(currentJsonFile);
                }
                else {

                    treeDraw(currentJsonFile);

                    treeIsDrew = true;
                }



            });

        //TODO Add mouse click

        bubble.append('title')
            .attr('x', function(d){ return radius(d.height); })
            .text(function(d){
                return d.personaType;
            });

        // adding label. For x-axis, it's at (10, 10), and for y-axis at (width, height-10).
        svg_chart.append('text')
            .attr('x', 10)
            .attr('y', -10)
            .attr('class', 'label')
            .text('States Visited');


        svg_chart.append('text')
            .attr('x', width )
            .attr('y', 420 + 50)
            .attr('text-anchor', 'end')
            .attr('class', 'label')
            .text('Time Elapsed in ms');

        // I feel I understand legends much better now.
        // define a group element for each color i, and translate it to (0, i * 20).
        var legend = svg_chart.selectAll('legend')
            .data(color.domain())
            .enter().append('g')
            .attr('class', 'legend')
            .attr('transform', function(d,i){ return 'translate(0,' + i * 20 + ')'; });

        // give x value equal to the legend elements.
        // no need to define a function for fill, this is automatically fill by color.
        legend.append('rect')
            .attr('x', width - 60)
            .attr('width', 18)
            .attr('height', 18)
            .style('fill', color);

        // add text to the legend elements.
        // rects are defined at x value equal to width, we define text at width - 6, this will print name of the legends before the rects.
        legend.append('text')
            .attr('x', width - 70)
            .attr('y', 9)
            .attr('dy', '.35em')
            .style('text-anchor', 'end')
            .text(function(d){ return d; });


        // d3 has a filter fnction similar to filter function in JS. Here it is used to filter d3 components.
        legend.on('click', function(type){
            d3.selectAll('.bubble')
                .style('opacity', 0.15)
                .filter(function(d){
                    return d.personaType == type;
                })
                .style('opacity', 1);
        })


    })

</script>


<script>


    // Set the dimensions and margins of the diagram
    var margin = {top: 20, right: 90, bottom: 30, left: 90},
        treeGraph_width = 4000 - margin.left - margin.right,
        treeGraph_height = 4000 - margin.top - margin.bottom;

    var colorScale = d3.scaleLinear()
        .domain([0, 1])
        .range(['red', 'green']);
    var widthScale = d3.scaleLinear()
        .domain([1,80])
        .range([1, 10]);


    var currentJsonFile = "data.json";
    var currentJsonFileName = "";

    var finalMaxTotalValue = 0;
    var initialHeuristicScore = 0;


    var clusteringDataSet = [];
    var clusterDict = {};

    //Set up Default Grid Size
    var rowNum = 5;
    var colNum = 5;

    var rowColRatio = 1;


    var means = [];
    var assignments = [];
    var dataRange;
    var drawDelay = 2000;

    var dataExtremes;


    // Set up the ToolTips
    var graph_tool_tip = d3.tip()
        .attr('class', 'svg_graph_d3-tip')
        .offset([-10, 0])
        .html(function(d) {
            return "<strong>Action Taken: </strong> <span style='color:red'>" + d.data.action + "</span>" + "<br>" + "<br>" +
                "<strong>Percentage of Winning: </strong> <span style='color:red'>" + ((((initialHeuristicScore - d.data.score) / initialHeuristicScore) +  d.data.rewards) * 100).toFixed(2) + "% "+ "</span>" + "<br>" + "<br>" +
                "<strong>Heuristic Score: </strong> <span style='color:red'>" + d.data.heuristicScore + "</span>" + "<br>" +
                "<strong>Game Score: </strong> <span style='color:red'>" + d.data.score + "</span>" + "<br>" +
                "<strong>Edited Distance From Root: </strong> <span style='color:red'>" + d.data.editedDistanceFromRoot + "</span>" + "<br>" +


                "<strong>Cluster: </strong> <span style='color:red'>" + d.data.cluster + "</span>" + "<br>" +
                "<strong>Height: </strong> <span style='color:red'>" + d.data.height + "</span>" + "<br>" +
                "<strong>Cost: </strong> <span style='color:red'>" + d.data.cost + "</span>" + "<br>" +
                "<strong>Rewards: </strong> <span style='color:red'>" + d.data.rewards + "</span>" + "<br>" +

                "<strong>Total Value JS: </strong> <span style='color:red'>" + d.data.totalValue_js + "</span>" + "<br>" +
                "<strong>Number of Visits JS: </strong> <span style='color:red'>" + d.data.visit_js + "</span>" + "<br>" +

                "<strong>Total Value: </strong> <span style='color:red'>" + d.data.totValue + "</span>" + "<br>" +
                "<strong>Number of Visits: </strong> <span style='color:red'>" + d.data.nVisits + "</span>" + "<br>" ;
        });


    //    treeDraw(currentJsonFile);



    function treeDraw(currentJson) {



        //Reset K-Mean Variables
        clusteringDataSet = [];
        clusterDict = {};

        means = [];
        assignments = [];
        dataRange = null;

        dataExtremes = null;

// load the external data
        d3.json(currentJson, function(error, treeData) {

            console.log("treeData: ", treeData);


            currentJsonFileName = treeData[0].rootNodeJSonFile;


            finalMaxTotalValue = treeData[0].finalMaxTotalValue;

            initialHeuristicScore = treeData[0].initialHeuristicScore;

            console.log(finalMaxTotalValue);
            console.log(initialHeuristicScore);

            var rootLevelMapString = "";

            treeData[0].levelMap.forEach(function(line) {


                rootLevelMapString = rootLevelMapString + line;

            })


            console.log("rootLevelMapString:", rootLevelMapString);



            rowNum = treeData[0].stateMap.length;
            colNum = treeData[0].stateMap[0].length;

            rowColRatio = 1 + (  Math.min(rowNum, colNum)/  Math.max(rowNum, colNum));

            ratio_Max =  Math.max(rowNum, colNum);
            ratio_Min =  Math.min(rowNum, colNum);

            var viewBoxWidth = 400; //* rowColRatio;
            var viewBoxHeight = 400; //* rowColRatio;

            if (( ratio_Max  / ratio_Min) > 2){

                if (rowNum > colNum){

                    viewBoxWidth = viewBoxWidth * 4;
                }
                else if (rowNum < colNum) {
                    viewBoxHeight = viewBoxHeight * 4;
                }
            }





            // append the svg object to the body of the page
            // appends a 'group' element to 'svg'
            // moves the 'group' element to the top left margin
            var svg = d3.select("body").append("svg")
                .attr("width", treeGraph_width + margin.right + margin.left)
                .attr("height", treeGraph_height + margin.top + margin.bottom)
                .attr('class', 'svg_treeGraph')
                .append("g")
                .attr("transform", "translate("
                    + margin.left + "," + margin.top + ")");


                svg.append("rect")
                    .attr('class', 'svg_treeGraph_BG')
                    .attr("width", "100%")
                    .attr("height", "100%")
                    .attr("fill", "white");

            var i = 0,
                duration = 750,
                root;

            // declares a tree layout and assigns the size
            var treemap = d3.tree().size([treeGraph_height, treeGraph_width]);
            //var treemap = d3.cluster().size([treeGraph_height, treeGraph_width]);

            // Assigns parent, children, height, depth
            root = d3.hierarchy(treeData[0], function (d) {
                return d.children;
            });
            root.x0 = treeGraph_height / 2;
            root.y0 = 0;



            // Call Tool Tip
            svg.call(graph_tool_tip);


//
//            for (var dimension in clusteringDataSet)
//            {
//
//                console.log(clusteringDataSet[dimension].heuristicScore);
//
//                ranges[dimension] = clusteringDataSet[dimension].max - clusteringDataSet[dimension].min;
//            }





            // Collapse after the second level
            //root.children.forEach(collapse); // Commented out for not being collapsed by default

            // Collapse after the second level
            //root.children.forEach(collapseIfNotFinal); // Commented out for not being collapsed by default



            update(root);



            // Collapse the node and all it's children
            function collapse(d) {
                if (d.children) {

                    console.log("d:  ", d);

                    d._children = d.children
                    d._children.forEach(collapse)
                    d.children = null
                }
            }




            // Collapse the node and all it's children
            function collapseIfNotFinal(d) {


                if (d.children) {

                     if ( d.data.isFinalPath === false){


//                         d._children = d.children
//                         d._children.forEach(collapse)
//                         d.children = null



                         console.log("got here at collapseIfNotFinal ");
                         console.log("d:  ", d);

                         d._children = d.children
                         d._children.forEach(collapseIfNotFinal)
                         d.children = null

                         //TODO Modifiy the visual of the d


                         //TODO take the verage Cluster number from the Child

                         //


                     }
                     else {
                         //d._children = d.children
                         d.children.forEach(collapseIfNotFinal)
                         //d.children = null



                     }


                }
            }










            function update(source) {



                var treeGraphBackground = d3.select('.svg_treeGraph_BG')
                                            .on('click', function(){

                                                console.log("Click background");
                                                unhighlight()
                                            });



                // Assigns the x and y position for the nodes
                var treeData = treemap(root);

                // Compute the new tree layout.
                var nodes = treeData.descendants(),
                    links = treeData.descendants().slice(1);

                // Normalize for fixed-depth.
                nodes.forEach(function (d) {
                    d.y = d.depth * 180


                    var thisMapString = "";

                    d.data.levelMap.forEach(function(line) {


                        thisMapString = thisMapString + line;

                    })


                    // Get Edit Distance
                    var thisEditDistance = calculateLevDistance(rootLevelMapString,thisMapString);

                    d.data.editedDistanceFromRoot = thisEditDistance;



                    // Backup MTCS Like data flow up
//                    console.log("d: ", d);

                    var currentNode = d;

                    while (currentNode.parent != null){


                        currentNode.data.visit_js = currentNode.data.visit_js + 1;

                        currentNode.data.totalValue_js = currentNode.data.totalValue_js +  d.data.totValue;

                        currentNode = currentNode.parent;

                        if (currentNode.parent == null){

                            currentNode.data.visit_js = currentNode.data.visit_js + 1;
                        }

                    }


                    // Prepare data for K-Means
                    clusteringDataSet.push(d.data);
                    clusterDict[d.data.name] = 0;



                });




                //TODO clustering on clusteringDataSet

                console.log("clusteringDataSet: ", clusteringDataSet);


                dataExtremes = getDataExtremes(clusteringDataSet);

                console.log("extremes: ", dataExtremes);


                dataRange = getDataRanges(dataExtremes);


                console.log("range: ", dataRange);


                means = initMeans(3);

                console.log("means: ", means);


                makeAssignments();

                setTimeout(runKMeans, drawDelay);

//                console.log("runKMeans assignments: ", assignments);


                for ( var i in clusteringDataSet){


                    clusterDict[clusteringDataSet[i].name] = assignments[i];
                }





                nodes.forEach(function (d) {

                    // TODO clustering assign cluster from clusterDict

                    d.data.cluster = clusterDict[d.data.name];


                });



                //TODO Function for clustering when hover over a specific node

                    //TODO Reset then in nodes.forEach , clusteringDataSet.push(d.data); clusterDict[d.data.name] = 0;  reassign Edit Distance

                         // var thisEditDistance = calculateLevDistance(rootLevelMapString,thisMapString);

                        //d.data.editedDistanceFromRoot = thisEditDistance;








                // ****************** Nodes section ***************************

                // Update the nodes...
                var node = svg.selectAll('g.node')
                    .data(nodes, function (d) {
                        return d.id || (d.id = ++i);
                    });

                // Enter any new modes at the parent's previous position.
                var nodeEnter = node.enter().append('g')
                    .attr('class', 'node')
                    .attr("transform", function (d) {
                        return "translate(" + source.y0 + "," + source.x0 + ")";
                    })
                    .on('click', click)
                    .on('dblclick',doubleClick)
                    .on('contextmenu', d3.contextMenu(menu))
                    .on('mouseover', graph_tool_tip.show)
                    .on('mouseout', graph_tool_tip.hide);







                // Add Circle for the nodes
                nodeEnter.append('circle')
                    .attr('class', 'node')
                    .attr('r', 1e-6)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    }).style("stroke", function(d){

                        return d._children ? "#0095d2" : "#fff";
                    }).style("stroke-width", function(d){

                    return d._children ? 5 : 0;
                });

                // Add labels for the nodes
                nodeEnter.append('text')
                    .attr('class', 'nodeText')
                    .attr("dy", ".35em")
                    .attr("x", function (d) {
                        return d.children || d._children ? -13 * rowColRatio : 13 * rowColRatio;
                    })
                    .attr("text-anchor", function (d) {
                        return d.children || d._children ? "end" : "start";
                    })
                    .text(function (d) {
                        return d.data.name;
                    })
                    .text(function(d) {
                        return d.data.name + " (" +  d.data.avatarStatus + ")"; })
                    .style("fill", function(d){

                        if (d.data.avatarStatus == "gotKilled"){

                            return "red";

                        }
                        else if(d.data.avatarStatus == "gotAResource"){

                            return "darkOrange";
                        }
                        else if(d.data.avatarStatus == "gotGoal"){

                            return "blue";
                        }
                        else if(d.data.avatarStatus == "killedAEnemy"){

                            return "green";
                        }
                    });



                ////
                var currentGridData = null;


                console.log("nodeEnter: ", nodeEnter);


                var thisGrid = nodeEnter
                    .append("svg")
                    .attr("class", "grid_svg")
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .attr("viewBox", "0 0 " + viewBoxWidth + " " + viewBoxHeight ) // This should be in porpotion
                    .attr("x", -10)
                    .attr("y", -10)
                    .attr("height", 30 * rowColRatio)
                    .attr("width", 30 * rowColRatio)
                    .on( 'mouseenter', function(d) {



                        //TODO if the same node is selected, don't need to recalculate the means
                        if(currentSelectedNode != d) {

                            //Reset K-Mean Variables
                            clusteringDataSet = [];
                            clusterDict = {};

                            means = [];
                            assignments = [];
                            dataRange = null;

                            dataExtremes - null;



                            //TODO when mouse Enter, select the current node as the baseline for the distance calculation
                            var currentSelectedLevelMapString = "";

                            d.data.levelMap.forEach(function(line) {


                                currentSelectedLevelMapString = currentSelectedLevelMapString + line;

                            });



                            //TODO reset clustering
                            nodes.forEach(function (d) {

                                // TODO clustering assign cluster from clusterDict

//                            d.data.cluster = clusterDict[d.data.name];
//
                                var thisMapString = "";

                                d.data.levelMap.forEach(function(line) {


                                    thisMapString = thisMapString + line;

                                })

                                // Get Edit Distance
                                var thisEditDistance = calculateLevDistance(currentSelectedLevelMapString,thisMapString);

                                d.data.editedDistanceFromRoot = thisEditDistance;



                                // Prepare data for K-Means
                                clusteringDataSet.push(d.data);
                                clusterDict[d.data.name] = 0;



                            });



                            //TODO clustering on clusteringDataSet

                            console.log(clusteringDataSet);


                            dataExtremes = getDataExtremes(clusteringDataSet);

                            console.log("extremes: ", dataExtremes);


                            dataRange = getDataRanges(dataExtremes);


                            console.log("range: ", dataRange);


                            means = initMeans(3);

                            console.log("means: ", means);



                            makeAssignments();

                            setTimeout(runKMeans, drawDelay);

//

                            for ( var i in clusteringDataSet){


                                clusterDict[clusteringDataSet[i].name] = assignments[i];
                            }


                            nodes.forEach(function (d) {

                                // TODO clustering assign cluster from clusterDict

                                d.data.cluster = clusterDict[d.data.name];


                            });



                            console.log("Updated currentSelectedNode: ", currentSelectedNode);
                            currentSelectedNode = d;




                        };




                        highlight(d.data.cluster);


                        // select element in current context
                        d3.select( this )
                            .transition()
                            .attr("height", 500 * rowColRatio)
                            .attr("width", 500 * rowColRatio);


                    })
                    // set back
                    .on( 'mouseleave', function() {

                       // unhighlight();

                        d3.select( this )
                            .transition()
                            .attr("height", 30 * rowColRatio)
                            .attr("width", 30 * rowColRatio);
                    });




                console.log("thisGrid: ", thisGrid);

                var row = thisGrid.selectAll(".row")
                    .data(function(d) {




                        currentGridData = getGridData(d.data.stateMap, rowNum ,colNum);

                        return currentGridData; })
                    .enter().append("g")
                    .attr("class", "row");


                var cell = row.selectAll(".cell")
                    .data(function(d) { return d; })
                    .enter().append("svg:g")
                    .attr("class", "cell");


                var column = cell.append("rect")
                    .attr("class","square")
                    .attr("x", function(d) { return d.x; })
                    .attr("y", function(d) { return d.y; })
                    .attr("width", function(d) { return d.width; })
                    .attr("height", function(d) { return d.height; })
                    .style("fill",  function(d) { return   "url(#grump_avatar" + d.id + ")" ; })
                    .style("stroke", "#222")
                    .text(function(d) { return d.imgStr; });


                var   defs = cell.append('svg:defs');



                defs.append("svg:pattern")
                    .attr("id",  function(d) { return   "grump_avatar" + d.id ; })
                    .attr("width", config.avatar_size)
                    .attr("height", config.avatar_size)
                    .attr("patternUnits", "userSpaceOnUse");

                cell.append("svg:image")
                    .attr("xlink:href",  function(d) { return  'http://localhost:8080/images/sprites/' + d.imgStr + '.png'; } )
                    .attr("width", config.avatar_size)
                    .attr("height", config.avatar_size)
                    .attr("x", function(d) { return d.x; })
                    .attr("y", function(d) { return d.y; });




//                var DOMURL = window.URL || window.webkitURL || window;
//
//                var svgString = domNodeToString(thisGrid.node());
//
////                console.log("svgString: ", svgString);
//
//                var image = new Image();
//                var svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
//                var url = DOMURL.createObjectURL(svgBlob);
//
//                image.onload = function() {
//                    context.drawImage(image, 0, 0);
//                    DOMURL.revokeObjectURL(url);
//                }
//
//                image.src = url;




                // UPDATE
                var nodeUpdate = nodeEnter.merge(node);

                // Transition to the proper position for the node
                nodeUpdate.transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + d.y + "," + d.x + ")";
                    });

                // Update the node attributes and style
                nodeUpdate.select('circle.node')
                   // .data(color.domain())
                    .attr('r', 15)
                    .style("fill", function (d) {

                        //TODO IF cluster not = 0, change color
                        if (d.data.cluster != null ){

                            return  colorSet[d.data.cluster];
                        }


                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .attr('cursor', 'pointer');


                // Remove any exiting nodes
                var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + source.y + "," + source.x + ")";
                    })
                    .remove();

                // On exit reduce the node circles size to 0
                nodeExit.select('circle')
                    .attr('r', 1e-6);

                // On exit reduce the opacity of text labels
                nodeExit.select('text')
                    .style('fill-opacity', 1e-6);

                // ****************** links section ***************************

                // Update the links...
                var link = svg.selectAll('path.link')
                    .data(links, function (d) {
                        return d.id;
                    })
                    .style('stroke-width', function (d) {
                        return widthScale(d.data.value)
                    });

                // Enter any new links at the parent's previous position.
                var linkEnter = link.enter().insert('path', "g")
                    .attr("class", "link")
                    .attr('d', function (d) {
                        var o = {x: source.x0, y: source.y0}
                        return diagonal(o, o)
                    })
                    .style("stroke-width", function(d){


                        if(d.data.isSelected == true && d.parent.data.isSelected == true && d.data.isFinalPath == true && d.parent.data.isFinalPath == true){

                            return 5 ;
                        }
                        else if (d.data.isSelected == true && d.parent.data.isSelected == true){


                            return 3;
                        }
                        else return 1 ;
                    })
                    .style("stroke", function(d){


                            if(d.data.isSelected == true && d.parent.data.isSelected == true && d.data.isFinalPath == true && d.parent.data.isFinalPath == true){

                                return "#0097FF" ;
                            }
                            else if (d.data.isSelected == true && d.parent.data.isSelected == true){

                                return "#ff66ab" ;
                            }
                            else return "grey" ;
                        }
                    );



                // UPDATE
                var linkUpdate = linkEnter.merge(link);

                // Transition back to the parent element position
                linkUpdate.transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        return diagonal(d, d.parent)
                    });

                // Remove any exiting links
                var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        var o = {x: source.x, y: source.y}
                        return diagonal(o, o)
                    })
                    .style('stroke-width', function (d) {


                        return 2 //widthScale(d.data.value)


                    })
                    .remove();

                // Store the old positions for transition.
                nodes.forEach(function (d) {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                // Creates a curved (diagonal) path from parent to the child nodes
                function diagonal(s, d) {

                    path = `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`

                    return path
                }

////                 Toggle children on click.
//                function click(d) {
//                    if (d.children) {
//                        d._children = d.children;
//                        d.children = null;
//                    } else {
//                        d.children = d._children;
//                        d._children = null;
//                    }
//                    update(d);
//                }



                function fade(opacity) {
                    return d => {
                        node.style('stroke-opacity', function (o) {
                            const thisOpacity = isConnected(d, o) ? 1 : opacity;
                            this.setAttribute('fill-opacity', thisOpacity);
                            return thisOpacity;
                        });

                        link.style('stroke-opacity', o => (o.source === d || o.target === d ? 1 : opacity));
                        link.attr('marker-end', o => (opacity === 1 || o.source === d || o.target === d ? 'url(#end-arrow)' : 'url(#end-arrow-fade)'));
                    };
                }


                function unhighlight() {
                    d3.selectAll(".node")
                        .style("fill", function(d){

                            if (d.data.avatarStatus == "gotKilled"){

                                return "red";

                            }
                            else if(d.data.avatarStatus == "gotAResource"){

                                return "darkOrange";
                            }
                            else if(d.data.avatarStatus == "gotGoal"){

                                return "blue";
                            }
                            else if(d.data.avatarStatus == "killedAEnemy"){

                                return "green";
                            }
                            else {
                                return  "#ff5b67" ;

                            }
                        }).style("stroke", function(d){

                        return d._children ? "#0095d2" : "#fff";
                    }).style("stroke-width", function(d){

                            return d._children ? 5 : 0;
                        }).style("opacity", 1);


                    d3.selectAll(".link").style("stroke-opacity", 1);

                    d3.selectAll(".nodeText").style("stroke-width", 0);
                }

                function highlight(clusterId) {
                    // First unhighlight all the circles.
                    unhighlight();

                    // Find the circles that have an id
                    // in the array of ids given, and
                    // highlight those.
                    d3.selectAll(".node").filter(function(d, i) {
                        return d.data.cluster != clusterId;
                    }).style("opacity", 0.2).style('stroke-opacity', 1)
                        .style("fill", "#D1FFFF");

                    d3.selectAll(".link").filter(function(d, i) {
                        return d.data.cluster != clusterId;
                    }).style('stroke-opacity', 0.2);



                }



                // Toggle children on click.
                function doubleClick(d) {


                    console.log("DoubleClicked");



                    //Prepareing path to send back to Cicero
                    var currentNode = d;

                    var path = currentNode.data.name;

                    var symbol = '>';

                    while (currentNode.parent != null){


                        path =   symbol + path;
                        var parentName = currentNode.parent.data.name;
                        path =  parentName + path;


                        currentNode = currentNode.parent;

                    }


                    console.log("path", path);



                    var xhr = new XMLHttpRequest();
                    xhr.open('POST', 'http://localhost:8080/api/generateRerunMessage');
                    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

                    xhr.onreadystatechange = function() {//Call a function when the state changes.
                        if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                            // Request finished. Do processing here.

//                alert(xhr.responseText);


                        }
                    };


                    var params = 'fileName=' + currentJsonFileName + "&path=" + path;

                    console.log("params: ", params);

                    xhr.send(params);




                    var xhr = new XMLHttpRequest();
                    xhr.open('POST', 'http://localhost:8080/api/deleteGameLevelFile');
                    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

                    xhr.onreadystatechange = function() {//Call a function when the state changes.
                        if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                            // Request finished. Do processing here.

//                alert(xhr.responseText);


                        }
                    };




                    var gameNameParts =  d.data.gameName.split("/");
                    var gameName = gameNameParts.pop();



                    var param = 'gameName=' + gameName;

                    console.log("param: ", param);

                    xhr.send(param);

//
//
//
                    for (i = 0; i < d.data.levelMap.length; i++) {


                        console.log(d.data.levelMap[i]);


//            characters =  encodeURIComponent(d.levelMap[i]);
//
//            console.log("character: ", characters);

//
                        var xhr = new XMLHttpRequest();
                        xhr.open('POST', 'http://localhost:8080/api/constructLevelMap');

                        //Send the proper header information along with the request
                        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

                        xhr.onreadystatechange = function() {//Call a function when the state changes.
                            if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                                // Request finished. Do processing here.

                                //    alert(xhr.responseText);


                            }
                        };



                        var params = 'row=' + d.data.levelMap[i]+ "&gameName=" + gameName;

                        console.log("params: ", params);

                        xhr.send(params);




                    }

                    // End of httprequest


                    console.log("d.data.levelMap: ", d.data.levelMap);


                    loader.style.left = d.x;
                    loader.style.top = d.y + 1000;

                    loader.style.display = "block";



                    // Redraw tree with rerun data
                    setTimeout(function(){

                        //  alert("Rerun completed!");

                        loader.style.display = "none";

                        if (treeIsDrew){


                            d3.selectAll(".svg_treeGraph").remove();

                            treeDraw(currentJsonFile);
                        }
                        else {

                            treeDraw(currentJsonFile);

                            treeIsDrew = true;
                        }






                    }, 3500);



                }


                // Toggle children on click.
                function click(d) {

                    console.log("clicked");

                    if (d.children) {


                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }


//                    console.log("currentJsonFileName: ", currentJsonFileName);
//

                    update(d);

                }


            }
        })

    }

</script>


<script>



    function treeUpdate(currentJson) {

// load the external data
        d3.json(currentJson, function(error, treeData) {



            // append the svg object to the body of the page
            // appends a 'group' element to 'svg'
            // moves the 'group' element to the top left margin

//            var svg = d3.select("body").append("svg")
//                .attr("width", treeGraph_width + margin.right + margin.left)
//                .attr("height", treeGraph_height + margin.top + margin.bottom)
//                .append("g")
//                .attr("transform", "translate("
//                    + margin.left + "," + margin.top + ")");

            var svg  = d3.selectAll(".svg_treeGraph");

            var i = 0,
                duration = 750,
                root;

            // declares a tree layout and assigns the size
            var treemap = d3.tree().size([treeGraph_height, treeGraph_width]);

            // Assigns parent, children, height, depth
            root = d3.hierarchy(treeData[0], function (d) {
                return d.children;
            });
            root.x0 = treeGraph_height / 2;
            root.y0 = 0;

            // Collapse after the second level
            root.children.forEach(collapse); // Commented out for not being collapsed by default

            update(root);

            // Collapse the node and all it's children
            function collapse(d) {
                if (d.children) {
                    d._children = d.children
                    d._children.forEach(collapse)
                    d.children = null
                }
            }

            function update(source) {

                // Assigns the x and y position for the nodes
                var treeData = treemap(root);

                // Compute the new tree layout.
                var nodes = treeData.descendants(),
                    links = treeData.descendants().slice(1);

                // Normalize for fixed-depth.
                nodes.forEach(function (d) {
                    d.y = d.depth * 180
                });

                // ****************** Nodes section ***************************

                // Update the nodes...
                var node = svg.selectAll('g.node')
                    .data(nodes, function (d) {
                        return d.id || (d.id = ++i);//this is a comment
                    });

                node.exit().remove();//remove unneeded node

                // Enter any new modes at the parent's previous position.
                var nodeEnter = node.enter().append('g')
                    .attr('class', 'node')
                    .attr("transform", function (d) {
                        return "translate(" + source.y0 + "," + source.x0 + ")";
                    })
                    .on('click', click)
                    .on('dblclick',doubleClick);

                // Add Circle for the nodes
                nodeEnter.append('circle')
                    .attr('class', 'node')
                    .attr('r', 1e-6)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .style("stroke", function (d) {


                        if (d.data.avatarStatus == "gotKilled"){

                            return "red";

                        }
                        else if(d.data.avatarStatus == "gotAResource"){

                            return "darkOrange";
                        }
                        else if(d.data.avatarStatus == "gotGoal"){

                            return "orange";
                        }
                        else if(d.data.avatarStatus == "killedAEnemy"){

                            return "green";
                        }
                        else{
                            return "black";
                        }


                    });

                // Add labels for the nodes
                nodeEnter.append('text')
                    .attr("dy", ".35em")
                    .attr("x", function (d) {
                        return d.children || d._children ? -28 : 28;
                    })
                    .attr("text-anchor", function (d) {
                        return d.children || d._children ? "end" : "start";
                    })
                    .text(function (d) {
                        return d.data.name;
                    })
                    .text(function(d) {
                        return d.data.name + " (" +  d.data.avatarStatus + ")"; })
                    .style("fill", function(d){

                        if (d.data.avatarStatus == "gotKilled"){

                            return "red";

                        }
                        else if(d.data.avatarStatus == "gotAResource"){

                            return "darkOrange";
                        }
                        else if(d.data.avatarStatus == "gotGoal"){

                            return "orange";
                        }
                        else if(d.data.avatarStatus == "killedAEnemy"){

                            return "green";
                        }
                    });

                // UPDATE
                var nodeUpdate = nodeEnter.merge(node);

                // Transition to the proper position for the node
                nodeUpdate.transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + d.y + "," + d.x + ")";
                    });

                // Update the node attributes and style
                nodeUpdate.select('circle.node')
                    .attr('r', 10)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .attr('cursor', 'pointer');


                // Remove any exiting nodes
                var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + source.y + "," + source.x + ")";
                    })
                    .remove();

                // On exit reduce the node circles size to 0
                nodeExit.select('circle')
                    .attr('r', 1e-6);

                // On exit reduce the opacity of text labels
                nodeExit.select('text')
                    .style('fill-opacity', 1e-6);

                // ****************** links section ***************************

                // Update the links...
                var link = svg.selectAll('path.link')
                    .data(links, function (d) {
                        return d.id;
                    })
                    .style('stroke-width', function (d) {
                        return widthScale(d.data.value)
                    });

                // Enter any new links at the parent's previous position.
                var linkEnter = link.enter().insert('path', "g")
                    .attr("class", "link")
                    .attr('d', function (d) {
                        var o = {x: source.x0, y: source.y0}
                        return diagonal(o, o)
                    })
                    .style('stroke-width', function (d) {


                        return 2 //widthScale(d.data.value)


                    });

                // UPDATE
                var linkUpdate = linkEnter.merge(link);

                // Transition back to the parent element position
                linkUpdate.transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        return diagonal(d, d.parent)
                    });

                // Remove any exiting links
                var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        var o = {x: source.x, y: source.y}
                        return diagonal(o, o)
                    })
                    .style('stroke-width', function (d) {


                        return 2 //widthScale(d.data.value)


                    })
                    .remove();

                // Store the old positions for transition.
                nodes.forEach(function (d) {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                // Creates a curved (diagonal) path from parent to the child nodes
                function diagonal(s, d) {

                    path = `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`

                    return path
                }

                // Toggle children on click.
                function click(d) {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }
                    update(d);
                }
            }
        })




    }

</script>


<script>

    function calculateLevDistance(src, tgt) {
        var realCost;

        var srcLength = src.length,
            tgtLength = tgt.length,
            tempString, tempLength; // for swapping

        var resultMatrix = new Array();
        resultMatrix[0] = new Array(); // Multi dimensional

        // To limit the space in minimum of source and target,
        // we make sure that srcLength is greater than tgtLength
        if (srcLength < tgtLength) {
            tempString = src; src = tgt; tgt = tempString;
            tempLength = srcLength; srcLength = tgtLength; tgtLength = tempLength;
        }

        for (var c = 0; c < tgtLength+1; c++) {
            resultMatrix[0][c] = c;
        }

        for (var i = 1; i < srcLength+1; i++) {
            resultMatrix[i] = new Array();
            resultMatrix[i][0] = i;
            for (var j = 1; j < tgtLength+1; j++) {
                realCost = (src.charAt(i-1) == tgt.charAt(j-1))? 0: 1;
                resultMatrix[i][j] = Math.min(
                    resultMatrix[i-1][j]+1,
                    resultMatrix[i][j-1]+1,
                    resultMatrix[i-1][j-1] + realCost // same logic as our previous example.
                );
            }
        }

        return resultMatrix[srcLength][tgtLength];
    }



    function getDataExtremes(data) {

        var extremes = [];

        for (var i in data)
        {
            var point = data[i];

            for (var dimension in point)
            {

                if(dimensionsForClustering.includes(dimension)){

                    if ( ! extremes[dimension] )
                    {
                        extremes[dimension] = {min: 1000, max: -10000000};
                    }

                    if (point[dimension] < extremes[dimension].min)
                    {
                        extremes[dimension].min = point[dimension];
                    }

                    if (point[dimension] > extremes[dimension].max)
                    {
                        extremes[dimension].max = point[dimension];
                    }

                }

            }
        }

        return extremes;
    }

    function getDataRanges(extremes) {
        var ranges = [];

        for (var dimension in extremes)
        {
            ranges[dimension] = extremes[dimension].max - extremes[dimension].min;
        }

        return ranges;

    }


    function initMeans(k) {

        if ( ! k )
        {
            k = 3;
        }

        while (k--)
        {
            var mean = [];

            for (var dimension in dataExtremes)
            {
                mean[dimension] = dataExtremes[dimension].min + ( Math.random() * dataRange[dimension] );
            }

            means.push(mean);
        }

        return means;

    };



    function makeAssignments() {



        for (var i in clusteringDataSet)
        {
            var point = clusteringDataSet[i];
            var distances = [];






            for (var j in means)
            {
                var mean = means[j];
                var sum = 0;

                for (var dimension in point)
                {
                    var difference = point[dimension] - mean[dimension];

                    if (isNaN(difference)){

                        difference = 0;
                    }

                    difference *= difference;
                    sum += difference;

                }



                distances[j] = Math.sqrt(sum);
            }

            assignments[i] = distances.indexOf( Math.min.apply(null, distances) );
        }

    }


    function moveMeans() {

        makeAssignments();

        var sums = Array( means.length );
        var counts = Array( means.length );
        var moved = false;

        for (var j in means)
        {
            counts[j] = 0;
            sums[j] = Array( means[j].length );
            for (var dimension in means[j])
            {
                sums[j][dimension] = 0;
            }
        }

        for (var point_index in assignments)
        {
            var mean_index = assignments[point_index];
            var point = clusteringDataSet[point_index];
            var mean = means[mean_index];

            counts[mean_index]++;

            for (var dimension in mean)
            {
                sums[mean_index][dimension] += point[dimension];
            }
        }

        for (var mean_index in sums)
        {



            if ( 0 === counts[mean_index] )
            {
                sums[mean_index] = means[mean_index];
                console.log("Mean with no points");



                for (var dimension in dataExtremes)
                {
                    sums[mean_index][dimension] = dataExtremes[dimension].min + ( Math.random() * dataRange[dimension] );
                }
                continue;
            }

            for (var dimension in sums[mean_index])
            {
                sums[mean_index][dimension] /= counts[mean_index];
            }
        }

        if (means.toString() !== sums.toString())
        {
            moved = true;
        }

        means = sums;

        return moved;

    }

    function runKMeans() {

        var moved = moveMeans();


        if (moved)
        {



            setTimeout(runKMeans, drawDelay);
        }



    }

</script>

</body>
</html>
