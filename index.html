<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Tree Example</title>

    <style>

        .node {
            cursor: pointer;
        }

        .node circle {
            fill: #fff;
            stroke: steelblue;
            stroke-width: 3px;
        }

        .node text {
            font: 12px sans-serif;
        }

        .link {
            fill: none;
            stroke: #ccc;
            stroke-width: 2px;
        }

    </style>

</head>

<body>

<!--&lt;!&ndash; load the d3.js library &ndash;&gt;-->
<!--<script src="https://d3js.org/d3.v4.min.js"></script>-->

<!-- load the d3.js library -->
<script src="http://d3js.org/d3.v3.min.js"></script>


<!-- load the grid.js  -->
<script src="grid.js" type="text/javascript"></script>

<!-- GLobal utilities variables  -->
<script>
    /*-- tooltip variables  --*/
    const tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("font-size",  12 + "px")
        .style("opacity", 0);
</script>
<script>



    // ************** Generate the tree diagram	 *****************
    var margin = {top: 20, right: 120, bottom: 80, left: 120},
        width = 3000 - margin.right - margin.left,
        height = 500 - margin.top - margin.bottom;

    var i = 0,
        duration = 750,
        root;

    var tree = d3.layout.tree()
        .size([height, width]);

    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");





    const currentJsonFile = "test.json";

    // d3.json block
    d3.json(currentJsonFile, function(error, treeData){


        root = treeData[0];
        root.x0 = height / 2;
        root.y0 = 0;

        update(root);

        d3.select(self.frameElement).style("height", "500px");

        function update(source) {

            // Compute the new tree layout.
            var nodes = tree.nodes(root).reverse(),
                links = tree.links(nodes);

            // Normalize for fixed-depth.
            nodes.forEach(function(d) { d.y = d.depth * 180; });

            // Update the nodes…
            var node = svg.selectAll("g.node")
                .data(nodes, function(d) { return d.id || (d.id = ++i); });

            // Enter any new nodes at the parent's previous position.
            var nodeEnter = node.enter().append("g")
                .attr("class", "node")
                .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
                .on("click", click)
                .on("mouseover", function(){return tooltip.style("visibility", "visible");})
                .on("mousemove", function(d){


                    tooltip.style("opacity", 100);
                    tooltip.text(d.action);


                    return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");}


                    )
                .on("mouseout", function(){return tooltip.style("visibility", "hidden");});

            var currentGridData = null;

            nodeEnter.append("text")
                .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
                .attr("dy", ".35em")
                .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
                .text(function(d) {
                    return d.name; })
                .style("fill-opacity", 1e-6);



            var thisGrid = nodeEnter
                .append("svg")
                .attr("class", "grid_svg")
                .attr("preserveAspectRatio", "xMinYMin meet")
                .attr("viewBox", "0 0 300 300")
                .attr("x", -10)
                .attr("y", -10)
                .attr("height", 25)
                .attr("width", 25)
                .on( 'mouseenter', function() {
                    // select element in current context
                    d3.select( this )
                        .transition()
                        .attr("height", 150)
                        .attr("width", 150);
                })
                // set back
                .on( 'mouseleave', function() {
                    d3.select( this )
                        .transition()
                        .attr("height", 25)
                        .attr("width", 25);
                });

            var row = thisGrid.selectAll(".row")
                .data(function(d) {

                    currentGridData = getGridData(d.stateMap);

                    return currentGridData; })
                .enter().append("g")
                .attr("class", "row");


            var cell = row.selectAll(".cell")
                .data(function(d) { return d; })
                .enter().append("svg:g")
                .attr("class", "cell");



            var column = cell.append("rect")
                .attr("class","square")
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; })
                .attr("width", function(d) { return d.width; })
                .attr("height", function(d) { return d.height; })
                .style("fill",  function(d) { return   "url(#grump_avatar" + d.id + ")" ; })
                .style("stroke", "#222")
                .text(function(d) { return d.imgStr; });


            var   defs = cell.append('svg:defs');



            defs.append("svg:pattern")
                .attr("id",  function(d) { return   "grump_avatar" + d.id ; })
                .attr("width", config.avatar_size)
                .attr("height", config.avatar_size)
                .attr("patternUnits", "userSpaceOnUse");

            cell.append("svg:image")
                .attr("xlink:href",  function(d) { return  'images/sprites/' + d.imgStr + '.png'; } )
                .attr("width", config.avatar_size)
                .attr("height", config.avatar_size)
                .attr("x", function(d) { return d.x; })
                .attr("y", function(d) { return d.y; });




            // Transition nodes to their new position.
            var nodeUpdate = node.transition()
                .duration(duration)
                .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

            nodeUpdate.select("circle")
                .attr("r", 10)
                .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

            nodeUpdate.select("text")
                .style("fill-opacity", 1);

            // Transition exiting nodes to the parent's new position.
            var nodeExit = node.exit().transition()
                .duration(duration)
                .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
                .remove();

            nodeExit.select("circle")
                .attr("r", 1e-6);

            nodeExit.select("text")
                .style("fill-opacity", 1e-6);

            // Update the links…
            var link = svg.selectAll("path.link")
                .data(links, function(d) { return d.target.id; });

            // Enter any new links at the parent's previous position.
            link.enter().insert("path", "g")
                .attr("class", "link")
                .attr("d", function(d) {
                    var o = {x: source.x0, y: source.y0};
                    return diagonal({source: o, target: o});
                })
                .style("stroke-width", function(d){

//                    console.log(d);

                    if (d.source.isSelected == true && d.target.isSelected == true){

                        return 3;
                    }
                    else return 1 ;
                })
                .style("stroke", function(d){

                        if (d.source.isSelected == true && d.target.isSelected == true){

                            return "#ff66ab" ;
                        }
                        else return "grey" ;
                    }
                );

            // Transition links to their new position.
            link.transition()
                .duration(duration)
                .attr("d", diagonal);

            // Transition exiting nodes to the parent's new position.
            link.exit().transition()
                .duration(duration)
                .attr("d", function(d) {
                    var o = {x: source.x, y: source.y};
                    return diagonal({source: o, target: o});
                })
                .remove();

            // Stash the old positions for transition.
            nodes.forEach(function(d) {
                d.x0 = d.x;
                d.y0 = d.y;
            });
        }



    });



    // Toggle children on click.
    function click(d) {





        if (d.children) {
            d._children = d.children;
            d.children = null;
        } else {
            d.children = d._children;
            d._children = null;
        }


        var xhr = new XMLHttpRequest();
        xhr.open('POST', 'http://localhost:8080/api/deleteGameLevelFile');
        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

        xhr.onreadystatechange = function() {//Call a function when the state changes.
            if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                // Request finished. Do processing here.

//                alert(xhr.responseText);


            }
        };

        var param = 'gameName=' + d.gameName;

        console.log("param: ", param);

        xhr.send(param);




        for (i = 0; i < d.levelMap.length; i++) {


            console.log(d.levelMap[i]);


//            characters =  encodeURIComponent(d.levelMap[i]);
//
//            console.log("character: ", characters);

//
            var xhr = new XMLHttpRequest();
            xhr.open('POST', 'http://localhost:8080/api/constructLevelMap');

            //Send the proper header information along with the request
            xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

            xhr.onreadystatechange = function() {//Call a function when the state changes.
                if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                    // Request finished. Do processing here.

                    alert(xhr.responseText);


                }
            };


//            var thisMapObject =

//            console.log(d.stateMap[i]);
//            console.log("d.levelMap[d.stateMap[i]]: ", d.levelMap["wall"]);



            var params = 'row=' + d.levelMap[i]+ "&gameName=" + d.gameName;

            console.log("params: ", params);

            xhr.send(params);


            for (j = 0; j < d.levelMap[i].length; j++){




            }

        }







        console.log(d.levelMap);



//        update(d);
    }

    // Create Event Handlers for mouse
    function handleMouseOver(d, i) {  // Add interactivity

        // Use D3 to select element, change color and size
        d3.select(this).attr({
            fill: "orange",
            r: radius * 2
        });

        // Specify where to put label of text
        svg.append("text").attr({
            id: "t" + d.x + "-" + d.y + "-" + i,  // Create an id for text so we can select it later for removing on mouseout
            x: function() { return xScale(d.x) - 30; },
            y: function() { return yScale(d.y) - 15; }
        })
            .text(function() {
                return [d.x, d.y];  // Value of the text
            });
    }



</script>

</body>
</html>
