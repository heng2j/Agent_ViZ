<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scatterplot d3v4</title>
    <style type="text/css">
        body{
            margin: 0;
            font-family: arial, sans;
        }

        .label{
            font-size: 15px;
        }

        .legend text,
        .axis text {
            font-size: 13px;
            fill: #333;
        }

        .axis path,
        .axis line{
            fill: none;
            stroke-width: 1px;
            stroke: #777;
        }

        .circle{
            fill-opacity: 0.65;
        }

        .bubble{
            opacity: 1;
            transition: opacity 0.3s;
        }

        .bubble:hover text{
            opacity: 1;
        }

        .bubble:hover circle{
            fill-opacity: 1;
        }

        .legend rect{
            fill-opacity: 0.75;
        }

        .legeng:hover rect{
            fill-opacity:1;
        }



        .svg_chart_d3-tip {
            line-height: 1;
            padding: 6px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Creates a small triangle extender for the tooltip */
        .svg_chart_d3-tip:after {
            box-sizing: border-box;
            display: inline;
            font-size: 10px;
            width: 100%;
            line-height: 1;
            color: rgba(0, 0, 0, 0.8);
            content: "\25BC";
            position: absolute;
            text-align: center;
        }

        /* Style northward tooltips specifically */
        .svg_chart_d3-tip.n:after {
            margin: -2px 0 0 0;
            top: 100%;
            left: 0;
        }





        .svg_graph_d3-tip {
            line-height: 1;
            padding: 6px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Creates a small triangle extender for the tooltip */
        .svg_graph_d3-tip:after {
            box-sizing: border-box;
            display: inline;
            font-size: 10px;
            width: 100%;
            line-height: 1;
            color: rgba(0, 0, 0, 0.8);
            content: "\25BC";
            position: absolute;
            text-align: center;
        }

        /* Style northward tooltips specifically */
        .svg_graph_d3-tip.n:after {
            margin: -2px 0 0 0;
            top: 100%;
            left: 0;
        }







        .node circle {
            fill: #999;
        }

        .node text {
            font: 10px sans-serif;
        }

        .node--internal circle {
            fill: #555;
        }

        .node--internal text {
            text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
        }

        .link {
            fill: none;
            stroke: #555;
            stroke-opacity: 1;
            stroke-width: 1.5px;
        }



        .slideComponent{

            position: absolute;
            left: 100px;
            top: 150px;
        }


    </style>
    <!--<script type="text/javascript" src="https://d3js.org/d3.v4.min.js"></script>-->
    <script type="text/javascript" src="http://localhost:8080/js/d3.min.js"></script>

    <!-- load the d3.tip.js library -->
    <script type="text/javascript" src="http://localhost:8080/js/d3-tip.js"></script>

    <!-- load the grid.js  -->
    <script src="http://localhost:8080/js/grid.js" type="text/javascript"></script>


</head>
<body>


<div class="slideComponent">

</div>




<script type="text/javascript">

    var treeIsDrew = false;

    var margin = {top: 30, right: 50, bottom: 50, left:40};
    var width = 960 - margin.left - margin.right;
    var height = 500 - margin.top - margin.bottom;

    var svg_chart = d3.select('body')
        .attr('class', 'svg_chart')
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');


    // The API for scales have changed in v4. There is a separate module d3-scale which can be used instead. The main change here is instead of d3.scale.linear, we have d3.scaleLinear.
    var xScale = d3.scaleLinear()
        .range([width, 0]);

    var yScale = d3.scaleLinear()
        .range([height, 0]);

    // square root scale.
    var radius = d3.scaleSqrt()
        .range([5,15]);

    // the axes are much cleaner and easier now. No need to rotate and orient the axis, just call axisBottom, axisLeft etc.
    var xAxis = d3.axisBottom()
        .scale(xScale);

    var yAxis = d3.axisLeft()
        .scale(yScale);

    // again scaleOrdinal
    var color = d3.scaleOrdinal(d3.schemeCategory20);


    // Set up the ToolTips


    var chart_tool_tip = d3.tip()
        .attr('class', 'svg_chart_d3-tip')
        .offset([-10, 0])
        .html(function(d) {
            return "<strong>Persona Type: </strong> <span style='color:red'>" + d.personaType + "</span>" + "<br>" + "<br>" +

                "<strong>TreeNode File Name: </strong> <span style='color:red'>" + d.TreeNodeFileName + "</span>" + "<br>" +

                "<strong>Number of Winnings: </strong> <span style='color:red'>" + d.gotGoalNum + "</span>" + "<br>" +
                "<strong>Number of Losses: </strong> <span style='color:red'>" + d.gotKilledNum + "</span>" + "<br>" +

                "<strong>Enemy Killed: </strong> <span style='color:red'>" + d.killedEnemyNum + "</span>" + "<br>" +

                "<strong>Resrouces Obtained: </strong> <span style='color:red'>" + d.gotResourceNum + "</span>" + "<br>" +

                "<strong>Total Avatar Events: </strong> <span style='color:red'>" + d.totalAvatarEvents + "</span>" + "<br>";
        });



    svg_chart.call(chart_tool_tip);


    d3.json('http://localhost:8080/jsonFiles/RootNodes.json', function(error, data){
        data.forEach(function(d){
            d.elapsedTime = +d.elapsedTime;  // X
            d.numNodesVisited = +d.numNodesVisited;  // Y
            d.height = +d.height; // radius
//            d.TreeNodeFileName = d.TreeNodeFileName;
        });

        xScale.domain(d3.extent(data, function(d){
            return d.elapsedTime;
        })).nice();

        yScale.domain(d3.extent(data, function(d){
            return d.numNodesVisited;
        })).nice();

        radius.domain(d3.extent(data, function(d){
            return d.height;
        })).nice();

        // adding axes is also simpler now, just translate x-axis to (0,height) and it's alread defined to be a bottom axis.
        svg_chart.append('g')
            .attr('transform', 'translate(0,' + 420 + ')')
            .attr('class', 'x axis')
            .call(xAxis);

        // y-axis is translated to (0,0)
        svg_chart.append('g')
            .attr('transform', 'translate(0,0)')
            .attr('class', 'y axis')
            .call(yAxis);


        var bubble = svg_chart.selectAll('.bubble')
            .data(data)
            .enter().append('circle')
            .attr('class', 'bubble')
            .attr('cx', function(d){return xScale(d.elapsedTime);})
            .attr('cy', function(d){ return yScale(d.numNodesVisited); })
            .attr('r', function(d){ return radius(d.height); })
            .style('fill', function(d){ return color(d.personaType); })
            .on('mouseover', chart_tool_tip.show)
            .on('mouseout', chart_tool_tip.hide)
            .on('click', function(d){

//                console.log(d.TreeNodeFileName);

                currentJsonFile = "http://localhost:8080/jsonFiles/" + d.TreeNodeFileName;

//                console.log(currentJsonFile);


                if (treeIsDrew){


                    d3.selectAll(".svg_treeGraph").remove();

                    treeDraw(currentJsonFile);
                }
                else {

                    treeDraw(currentJsonFile);

                    treeIsDrew = true;
                }



            });

        //TODO Add mouse click

        bubble.append('title')
            .attr('x', function(d){ return radius(d.height); })
            .text(function(d){
                return d.personaType;
            });

        // adding label. For x-axis, it's at (10, 10), and for y-axis at (width, height-10).
        svg_chart.append('text')
            .attr('x', 10)
            .attr('y', -10)
            .attr('class', 'label')
            .text('States Visited');


        svg_chart.append('text')
            .attr('x', width )
            .attr('y', 420 + 50)
            .attr('text-anchor', 'end')
            .attr('class', 'label')
            .text('Time Elapsed in ms');

        // I feel I understand legends much better now.
        // define a group element for each color i, and translate it to (0, i * 20).
        var legend = svg_chart.selectAll('legend')
            .data(color.domain())
            .enter().append('g')
            .attr('class', 'legend')
            .attr('transform', function(d,i){ return 'translate(0,' + i * 20 + ')'; });

        // give x value equal to the legend elements.
        // no need to define a function for fill, this is automatically fill by color.
        legend.append('rect')
            .attr('x', width - 60)
            .attr('width', 18)
            .attr('height', 18)
            .style('fill', color);

        // add text to the legend elements.
        // rects are defined at x value equal to width, we define text at width - 6, this will print name of the legends before the rects.
        legend.append('text')
            .attr('x', width - 70)
            .attr('y', 9)
            .attr('dy', '.35em')
            .style('text-anchor', 'end')
            .text(function(d){ return d; });


        // d3 has a filter fnction similar to filter function in JS. Here it is used to filter d3 components.
        legend.on('click', function(type){
            d3.selectAll('.bubble')
                .style('opacity', 0.15)
                .filter(function(d){
                    return d.personaType == type;
                })
                .style('opacity', 1);
        })


    })

</script>


<script>


    // Set the dimensions and margins of the diagram
    var margin = {top: 20, right: 90, bottom: 30, left: 90},
        treeGraph_width = 3000 - margin.left - margin.right,
        treeGraph_height = 2200 - margin.top - margin.bottom;

    var colorScale = d3.scaleLinear()
        .domain([0, 1])
        .range(['red', 'green']);
    var widthScale = d3.scaleLinear()
        .domain([1,80])
        .range([1, 10]);


    var currentJsonFile = "data.json";

    var finalMaxTotalValue = 0;
    var initialHeuristicScore = 0;


    //Set up Default Grid Size
    var rowNum = 5;
    var colNum = 5;

    var rowColRatio = 1;

    // Set up the ToolTips
    var graph_tool_tip = d3.tip()
        .attr('class', 'svg_graph_d3-tip')
        .offset([-10, 0])
        .html(function(d) {
            return "<strong>Action Taken: </strong> <span style='color:red'>" + d.data.action + "</span>" + "<br>" + "<br>" +
                "<strong>Percentage of Winning: </strong> <span style='color:red'>" + ((((initialHeuristicScore - d.data.score) / initialHeuristicScore) +  d.data.rewards) * 100).toFixed(2) + "% "+ "</span>" + "<br>" + "<br>" +
                "<strong>Heuristic Score: </strong> <span style='color:red'>" + d.data.score + "</span>" + "<br>" +
                "<strong>Height: </strong> <span style='color:red'>" + d.data.height + "</span>" + "<br>" +
                "<strong>Cost: </strong> <span style='color:red'>" + d.data.cost + "</span>" + "<br>" +
                "<strong>Total Value: </strong> <span style='color:red'>" + d.data.totValue + "</span>" + "<br>" +
                "<strong>Rewards: </strong> <span style='color:red'>" + d.data.rewards + "</span>" + "<br>" +
                "<strong>Number of Visits: </strong> <span style='color:red'>" + d.data.nVisits + "</span>" + "<br>" ;
        });


    //    treeDraw(currentJsonFile);



    function treeDraw(currentJson) {

// load the external data
        d3.json(currentJson, function(error, treeData) {

            console.log(treeData);



            finalMaxTotalValue = treeData[0].finalMaxTotalValue;

            initialHeuristicScore = treeData[0].initialHeuristicScore;

            console.log(finalMaxTotalValue);
            console.log(initialHeuristicScore);


            rowNum = treeData[0].stateMap.length;
            colNum = treeData[0].stateMap[0].length;

            rowColRatio = 1 + (  Math.min(rowNum, colNum)/  Math.max(rowNum, colNum));

            console.log("rowNum :", rowNum);
            console.log("colNum :", colNum);



            // append the svg object to the body of the page
            // appends a 'group' element to 'svg'
            // moves the 'group' element to the top left margin
            var svg = d3.select("body").append("svg")
                .attr("width", treeGraph_width + margin.right + margin.left)
                .attr("height", treeGraph_height + margin.top + margin.bottom)
                .attr('class', 'svg_treeGraph')
                .append("g")
                .attr("transform", "translate("
                    + margin.left + "," + margin.top + ")");

            var i = 0,
                duration = 750,
                root;

            // declares a tree layout and assigns the size
            var treemap = d3.tree().size([treeGraph_height, treeGraph_width]);

            // Assigns parent, children, height, depth
            root = d3.hierarchy(treeData[0], function (d) {
                return d.children;
            });
            root.x0 = treeGraph_height / 2;
            root.y0 = 0;


            svg.call(graph_tool_tip);

            // Collapse after the second level
            //    root.children.forEach(collapse); // Commented out for not being collapsed by default

            update(root);

            // Collapse the node and all it's children
            function collapse(d) {
                if (d.children) {
                    d._children = d.children
                    d._children.forEach(collapse)
                    d.children = null
                }
            }








            function update(source) {

                // Assigns the x and y position for the nodes
                var treeData = treemap(root);

                // Compute the new tree layout.
                var nodes = treeData.descendants(),
                    links = treeData.descendants().slice(1);

                // Normalize for fixed-depth.
                nodes.forEach(function (d) {
                    d.y = d.depth * 180
                });

                // ****************** Nodes section ***************************

                // Update the nodes...
                var node = svg.selectAll('g.node')
                    .data(nodes, function (d) {
                        return d.id || (d.id = ++i);
                    });

                // Enter any new modes at the parent's previous position.
                var nodeEnter = node.enter().append('g')
                    .attr('class', 'node')
                    .attr("transform", function (d) {
                        return "translate(" + source.y0 + "," + source.x0 + ")";
                    })
                    .on('click', click)
                    .on('mouseover', graph_tool_tip.show)
                    .on('mouseout', graph_tool_tip.hide);







                // Add Circle for the nodes
                nodeEnter.append('circle')
                    .attr('class', 'node')
                    .attr('r', 1e-6)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .style("stroke", function (d) {


                        if (d.data.avatarStatus == "gotKilled"){

                            return "red";

                        }
                        else if(d.data.avatarStatus == "gotAResource"){

                            return "darkOrange";
                        }
                        else if(d.data.avatarStatus == "gotGoal"){

                            return "blue";
                        }
                        else if(d.data.avatarStatus == "killedAEnemy"){

                            return "green";
                        }
                        else{
                            return "black";
                        }


                    });

                // Add labels for the nodes
                nodeEnter.append('text')
                    .attr("dy", ".35em")
                    .attr("x", function (d) {
                        return d.children || d._children ? -13 : 13;
                    })
                    .attr("text-anchor", function (d) {
                        return d.children || d._children ? "end" : "start";
                    })
                    .text(function (d) {
                        return d.data.name;
                    })
                    .text(function(d) {
                        return d.data.name + " (" +  d.data.avatarStatus + ")"; })
                    .style("fill", function(d){

                        if (d.data.avatarStatus == "gotKilled"){

                            return "red";

                        }
                        else if(d.data.avatarStatus == "gotAResource"){

                            return "darkOrange";
                        }
                        else if(d.data.avatarStatus == "gotGoal"){

                            return "blue";
                        }
                        else if(d.data.avatarStatus == "killedAEnemy"){

                            return "green";
                        }
                    });



                ////
                var currentGridData = null;

                var thisGrid = nodeEnter
                    .append("svg")
                    .attr("class", "grid_svg")
                    .attr("preserveAspectRatio", "xMinYMin meet")
                    .attr("viewBox", "0 0 900 2000") // This should be in porpotion
                    .attr("x", -10)
                    .attr("y", -10)
                    .attr("height", 30 * rowColRatio)
                    .attr("width", 30 * rowColRatio)
                    .on( 'mouseenter', function() {



                        // select element in current context
                        d3.select( this )
                            .transition()
                            .attr("height", 200 * rowColRatio)
                            .attr("width", 200 * rowColRatio);

                    })
                    // set back
                    .on( 'mouseleave', function() {

                        d3.select( this )
                            .transition()
                            .attr("height", 30 * rowColRatio)
                            .attr("width", 30 * rowColRatio);
                    });


                var row = thisGrid.selectAll(".row")
                    .data(function(d) {




                        currentGridData = getGridData(d.data.stateMap, rowNum ,colNum);

                        return currentGridData; })
                    .enter().append("g")
                    .attr("class", "row");


                var cell = row.selectAll(".cell")
                    .data(function(d) { return d; })
                    .enter().append("svg:g")
                    .attr("class", "cell");


                var column = cell.append("rect")
                    .attr("class","square")
                    .attr("x", function(d) { return d.x; })
                    .attr("y", function(d) { return d.y; })
                    .attr("width", function(d) { return d.width; })
                    .attr("height", function(d) { return d.height; })
                    .style("fill",  function(d) { return   "url(#grump_avatar" + d.id + ")" ; })
                    .style("stroke", "#222")
                    .text(function(d) { return d.imgStr; });


                var   defs = cell.append('svg:defs');



                defs.append("svg:pattern")
                    .attr("id",  function(d) { return   "grump_avatar" + d.id ; })
                    .attr("width", config.avatar_size)
                    .attr("height", config.avatar_size)
                    .attr("patternUnits", "userSpaceOnUse");

                cell.append("svg:image")
                    .attr("xlink:href",  function(d) { return  'http://localhost:8080/images/sprites/' + d.imgStr + '.png'; } )
                    .attr("width", config.avatar_size)
                    .attr("height", config.avatar_size)
                    .attr("x", function(d) { return d.x; })
                    .attr("y", function(d) { return d.y; });




                // UPDATE
                var nodeUpdate = nodeEnter.merge(node);

                // Transition to the proper position for the node
                nodeUpdate.transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + d.y + "," + d.x + ")";
                    });

                // Update the node attributes and style
                nodeUpdate.select('circle.node')
                    .attr('r', 10)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .attr('cursor', 'pointer');


                // Remove any exiting nodes
                var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + source.y + "," + source.x + ")";
                    })
                    .remove();

                // On exit reduce the node circles size to 0
                nodeExit.select('circle')
                    .attr('r', 1e-6);

                // On exit reduce the opacity of text labels
                nodeExit.select('text')
                    .style('fill-opacity', 1e-6);

                // ****************** links section ***************************

                // Update the links...
                var link = svg.selectAll('path.link')
                    .data(links, function (d) {
                        return d.id;
                    })
                    .style('stroke-width', function (d) {
                        return widthScale(d.data.value)
                    });

                // Enter any new links at the parent's previous position.
                var linkEnter = link.enter().insert('path', "g")
                    .attr("class", "link")
                    .attr('d', function (d) {
                        var o = {x: source.x0, y: source.y0}
                        return diagonal(o, o)
                    })
                    .style("stroke-width", function(d){

//                        console.log(d);
//                        console.log(d.data);
//                        console.log(d.parent.data);

                        if(d.data.isSelected == true && d.parent.data.isSelected == true && d.data.isFinalPath == true && d.parent.data.isFinalPath == true){

                            return 5 ;
                        }
                        else if (d.data.isSelected == true && d.parent.data.isSelected == true){


                            return 3;
                        }
                        else return 1 ;
                    })
                    .style("stroke", function(d){


                            if(d.data.isSelected == true && d.parent.data.isSelected == true && d.data.isFinalPath == true && d.parent.data.isFinalPath == true){

                                return "#0097FF" ;
                            }
                            else if (d.data.isSelected == true && d.parent.data.isSelected == true){

                                return "#ff66ab" ;
                            }
                            else return "grey" ;
                        }
                    );




//                    .style('stroke-width', function (d) {
//
//
//                        return 2 //widthScale(d.data.value)
//
//
//                    });

                // UPDATE
                var linkUpdate = linkEnter.merge(link);

                // Transition back to the parent element position
                linkUpdate.transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        return diagonal(d, d.parent)
                    });

                // Remove any exiting links
                var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        var o = {x: source.x, y: source.y}
                        return diagonal(o, o)
                    })
                    .style('stroke-width', function (d) {


                        return 2 //widthScale(d.data.value)


                    })
                    .remove();

                // Store the old positions for transition.
                nodes.forEach(function (d) {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                // Creates a curved (diagonal) path from parent to the child nodes
                function diagonal(s, d) {

                    path = `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`

                    return path
                }

                // Toggle children on click.
//                function click(d) {
//                    if (d.children) {
//                        d._children = d.children;
//                        d.children = null;
//                    } else {
//                        d.children = d._children;
//                        d._children = null;
//                    }
//                    update(d);
//                }


                // Toggle children on click.
                function click(d) {

//
//
//
//
//                    if (d.children) {
//                        d._children = d.children;
//                        d.children = null;
//                    } else {
//                        d.children = d._children;
//                        d._children = null;
//                    }

                    console.log("Selected d:" , d.data.name);

                    var xhr = new XMLHttpRequest();
                    xhr.open('POST', 'http://localhost:8080/api/deleteGameLevelFile');
                    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

                    xhr.onreadystatechange = function() {//Call a function when the state changes.
                        if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                            // Request finished. Do processing here.

//                alert(xhr.responseText);


                        }
                    };




                    var gameNameParts =  d.data.gameName.split("/");
                    var gameName = gameNameParts.pop();



                    var param = 'gameName=' + gameName;

                    console.log("param: ", param);

                    xhr.send(param);




                    for (i = 0; i < d.data.levelMap.length; i++) {


                        console.log(d.data.levelMap[i]);


//            characters =  encodeURIComponent(d.levelMap[i]);
//
//            console.log("character: ", characters);

//
                        var xhr = new XMLHttpRequest();
                        xhr.open('POST', 'http://localhost:8080/api/constructLevelMap');

                        //Send the proper header information along with the request
                        xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

                        xhr.onreadystatechange = function() {//Call a function when the state changes.
                            if(xhr.readyState == XMLHttpRequest.DONE && xhr.status == 200) {
                                // Request finished. Do processing here.

                                alert(xhr.responseText);


                            }
                        };


//            var thisMapObject =

//            console.log(d.stateMap[i]);
//            console.log("d.levelMap[d.stateMap[i]]: ", d.levelMap["wall"]);






                        var params = 'row=' + d.data.levelMap[i]+ "&gameName=" + gameName;

                        console.log("params: ", params);

                        xhr.send(params);


//                        for (j = 0; j < d.data.levelMap[i].length; j++){
//
//
//
//
//                        }

                    }


                    console.log(d.data.levelMap);



//        update(d);
                }

            }
        })

    }

</script>


<script>



    function treeUpdate(currentJson) {

// load the external data
        d3.json(currentJson, function(error, treeData) {



            // append the svg object to the body of the page
            // appends a 'group' element to 'svg'
            // moves the 'group' element to the top left margin

//            var svg = d3.select("body").append("svg")
//                .attr("width", treeGraph_width + margin.right + margin.left)
//                .attr("height", treeGraph_height + margin.top + margin.bottom)
//                .append("g")
//                .attr("transform", "translate("
//                    + margin.left + "," + margin.top + ")");

            var svg  = d3.selectAll(".svg_treeGraph");

            var i = 0,
                duration = 750,
                root;

            // declares a tree layout and assigns the size
            var treemap = d3.tree().size([treeGraph_height, treeGraph_width]);

            // Assigns parent, children, height, depth
            root = d3.hierarchy(treeData[0], function (d) {
                return d.children;
            });
            root.x0 = treeGraph_height / 2;
            root.y0 = 0;

            // Collapse after the second level
            //    root.children.forEach(collapse); // Commented out for not being collapsed by default

            update(root);

            // Collapse the node and all it's children
            function collapse(d) {
                if (d.children) {
                    d._children = d.children
                    d._children.forEach(collapse)
                    d.children = null
                }
            }

            function update(source) {

                // Assigns the x and y position for the nodes
                var treeData = treemap(root);

                // Compute the new tree layout.
                var nodes = treeData.descendants(),
                    links = treeData.descendants().slice(1);

                // Normalize for fixed-depth.
                nodes.forEach(function (d) {
                    d.y = d.depth * 180
                });

                // ****************** Nodes section ***************************

                // Update the nodes...
                var node = svg.selectAll('g.node')
                    .data(nodes, function (d) {
                        return d.id || (d.id = ++i);
                    });

                node.exit().remove();//remove unneeded node

                // Enter any new modes at the parent's previous position.
                var nodeEnter = node.enter().append('g')
                    .attr('class', 'node')
                    .attr("transform", function (d) {
                        return "translate(" + source.y0 + "," + source.x0 + ")";
                    })
                    .on('click', click);

                // Add Circle for the nodes
                nodeEnter.append('circle')
                    .attr('class', 'node')
                    .attr('r', 1e-6)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .style("stroke", function (d) {


                        if (d.data.avatarStatus == "gotKilled"){

                            return "red";

                        }
                        else if(d.data.avatarStatus == "gotAResource"){

                            return "darkOrange";
                        }
                        else if(d.data.avatarStatus == "gotGoal"){

                            return "orange";
                        }
                        else if(d.data.avatarStatus == "killedAEnemy"){

                            return "green";
                        }
                        else{
                            return "black";
                        }


                    });

                // Add labels for the nodes
                nodeEnter.append('text')
                    .attr("dy", ".35em")
                    .attr("x", function (d) {
                        return d.children || d._children ? -13 : 13;
                    })
                    .attr("text-anchor", function (d) {
                        return d.children || d._children ? "end" : "start";
                    })
                    .text(function (d) {
                        return d.data.name;
                    })
                    .text(function(d) {
                        return d.data.name + " (" +  d.data.avatarStatus + ")"; })
                    .style("fill", function(d){

                        if (d.data.avatarStatus == "gotKilled"){

                            return "red";

                        }
                        else if(d.data.avatarStatus == "gotAResource"){

                            return "darkOrange";
                        }
                        else if(d.data.avatarStatus == "gotGoal"){

                            return "orange";
                        }
                        else if(d.data.avatarStatus == "killedAEnemy"){

                            return "green";
                        }
                    });

                // UPDATE
                var nodeUpdate = nodeEnter.merge(node);

                // Transition to the proper position for the node
                nodeUpdate.transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + d.y + "," + d.x + ")";
                    });

                // Update the node attributes and style
                nodeUpdate.select('circle.node')
                    .attr('r', 10)
                    .style("fill", function (d) {
                        return d._children ? "lightsteelblue" : "#fff";
                    })
                    .attr('cursor', 'pointer');


                // Remove any exiting nodes
                var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function (d) {
                        return "translate(" + source.y + "," + source.x + ")";
                    })
                    .remove();

                // On exit reduce the node circles size to 0
                nodeExit.select('circle')
                    .attr('r', 1e-6);

                // On exit reduce the opacity of text labels
                nodeExit.select('text')
                    .style('fill-opacity', 1e-6);

                // ****************** links section ***************************

                // Update the links...
                var link = svg.selectAll('path.link')
                    .data(links, function (d) {
                        return d.id;
                    })
                    .style('stroke-width', function (d) {
                        return widthScale(d.data.value)
                    });

                // Enter any new links at the parent's previous position.
                var linkEnter = link.enter().insert('path', "g")
                    .attr("class", "link")
                    .attr('d', function (d) {
                        var o = {x: source.x0, y: source.y0}
                        return diagonal(o, o)
                    })
                    .style('stroke-width', function (d) {


                        return 2 //widthScale(d.data.value)


                    });

                // UPDATE
                var linkUpdate = linkEnter.merge(link);

                // Transition back to the parent element position
                linkUpdate.transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        return diagonal(d, d.parent)
                    });

                // Remove any exiting links
                var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr('d', function (d) {
                        var o = {x: source.x, y: source.y}
                        return diagonal(o, o)
                    })
                    .style('stroke-width', function (d) {


                        return 2 //widthScale(d.data.value)


                    })
                    .remove();

                // Store the old positions for transition.
                nodes.forEach(function (d) {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });

                // Creates a curved (diagonal) path from parent to the child nodes
                function diagonal(s, d) {

                    path = `M ${s.y} ${s.x}
                    C ${(s.y + d.y) / 2} ${s.x},
                      ${(s.y + d.y) / 2} ${d.x},
                      ${d.y} ${d.x}`

                    return path
                }

                // Toggle children on click.
                function click(d) {
                    if (d.children) {
                        d._children = d.children;
                        d.children = null;
                    } else {
                        d.children = d._children;
                        d._children = null;
                    }
                    update(d);
                }
            }
        })

    }

</script>

</body>
</html>
